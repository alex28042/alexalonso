{"ast":null,"code":"// Inspiration: https://github.com/facebook/react/issues/3386\nfunction replace(string, regexpOrSubstr, newValueOrFn, globalOffset) {\n  if (typeof string !== 'string') throw new Error('First param must be a string');\n  if (typeof regexpOrSubstr !== 'string' && !(regexpOrSubstr instanceof RegExp)) throw new Error('Second param must be a string pattern or a regular expression');\n  var fn = typeof regexpOrSubstr === 'string' ? replaceUsingString : replaceUsingRegexp;\n  return fn(string, regexpOrSubstr, newValueOrFn, globalOffset);\n}\n\nfunction replaceUsingString(string, patternString, newValueOrFn, globalOffset) {\n  var index = string.indexOf(patternString);\n\n  if (index >= 0) {\n    var arr = [];\n    var endIndex = index + patternString.length;\n\n    if (index > 0) {\n      arr.push(string.substring(0, index));\n    }\n\n    arr.push(typeof newValueOrFn === 'function' ? newValueOrFn(string.substring(index, endIndex), index + globalOffset, string) : newValueOrFn);\n\n    if (endIndex < string.length) {\n      arr.push(string.substring(endIndex));\n    }\n\n    return arr;\n  } else {\n    return [string];\n  }\n}\n\nfunction replaceUsingRegexp(string, regexp, newValueOrFn, globalOffset) {\n  var output = [];\n  var replacerIsFn = typeof newValueOrFn === 'function';\n  var storedLastIndex = regexp.lastIndex;\n  regexp.lastIndex = 0;\n  var result;\n  var lastIndex = 0;\n\n  while (result = regexp.exec(string)) {\n    var index = result.index;\n\n    if (result[0] === '') {\n      // When the regexp is an empty string\n      // we still want to advance our cursor to the next item.\n      // This is the behavior of String.replace.\n      regexp.lastIndex++;\n    }\n\n    if (index !== lastIndex) {\n      output.push(string.substring(lastIndex, index));\n    }\n\n    var match = result[0];\n    lastIndex = index + match.length;\n    var out = replacerIsFn ? newValueOrFn.apply(this, result.concat(index + globalOffset, result.input)) : newValueOrFn;\n    output.push(out);\n\n    if (!regexp.global) {\n      break;\n    }\n  }\n\n  if (lastIndex < string.length) {\n    output.push(string.substring(lastIndex));\n  }\n\n  regexp.lastIndex = storedLastIndex;\n  return output;\n}\n\nmodule.exports = function stringReplaceToArray(stringOrArray, regexpOrSubstr, newSubStrOrFn) {\n  if (typeof stringOrArray === 'string') {\n    return replace(stringOrArray, regexpOrSubstr, newSubStrOrFn, 0);\n  } else if (!Array.isArray(stringOrArray) || !stringOrArray[0]) {\n    throw new TypeError('First argument must be an array or non-empty string');\n  } else {\n    var len = stringOrArray.length;\n    var output = [];\n    var globalOffset = 0;\n\n    for (var i = 0; i < len; ++i) {\n      var arrayItem = stringOrArray[i];\n\n      if (typeof arrayItem === 'string') {\n        output.push.apply(output, replace(arrayItem, regexpOrSubstr, newSubStrOrFn, globalOffset));\n        globalOffset += arrayItem.length;\n      } else {\n        output.push(arrayItem);\n      }\n    }\n\n    return output;\n  }\n};","map":{"version":3,"names":["replace","string","regexpOrSubstr","newValueOrFn","globalOffset","Error","RegExp","fn","replaceUsingString","replaceUsingRegexp","patternString","index","indexOf","arr","endIndex","length","push","substring","regexp","output","replacerIsFn","storedLastIndex","lastIndex","result","exec","match","out","apply","concat","input","global","module","exports","stringReplaceToArray","stringOrArray","newSubStrOrFn","Array","isArray","TypeError","len","i","arrayItem"],"sources":["/home/alex/Escritorio/PortaFolio/alexalonso/node_modules/string-replace-to-array/string-replace-to-array.js"],"sourcesContent":["// Inspiration: https://github.com/facebook/react/issues/3386\n\nfunction replace (string, regexpOrSubstr, newValueOrFn, globalOffset) {\n\tif (typeof string !== 'string') throw new Error('First param must be a string')\n\tif (typeof regexpOrSubstr !== 'string' && !(regexpOrSubstr instanceof RegExp)) throw new Error('Second param must be a string pattern or a regular expression')\n\n\tvar fn = (typeof regexpOrSubstr === 'string') ? replaceUsingString : replaceUsingRegexp\n\n\treturn fn(string, regexpOrSubstr, newValueOrFn, globalOffset)\n}\n\nfunction replaceUsingString (string, patternString, newValueOrFn, globalOffset) {\n\tvar index = string.indexOf(patternString)\n\n\tif (index >= 0) {\n\t\tvar arr = []\n\t\tvar endIndex = index + patternString.length\n\n\t\tif (index > 0) {\n\t\t\tarr.push(string.substring(0, index))\n\t\t}\n\n\t\tarr.push(\n\t\t\t(typeof newValueOrFn === 'function') ?\n\t\t\t\tnewValueOrFn(\n\t\t\t\t\tstring.substring(index, endIndex),\n\t\t\t\t\tindex + globalOffset,\n\t\t\t\t\tstring\n\t\t\t\t) :\n\t\t\t\tnewValueOrFn\n\t\t)\n\n\t\tif (endIndex < string.length) {\n\t\t\tarr.push(string.substring(endIndex))\n\t\t}\n\n\t\treturn arr\n\t} else {\n\t\treturn [string]\n\t}\n}\n\nfunction replaceUsingRegexp (string, regexp, newValueOrFn, globalOffset) {\n\tvar output = []\n\n\tvar replacerIsFn = (typeof newValueOrFn === 'function')\n\n\tvar storedLastIndex = regexp.lastIndex\n\tregexp.lastIndex = 0\n\n\tvar result\n\tvar lastIndex = 0\n\twhile (result = regexp.exec(string)) {\n\t\tvar index = result.index\n\n\t\tif (result[0] === '') {\n\t\t\t// When the regexp is an empty string\n\t\t\t// we still want to advance our cursor to the next item.\n\t\t\t// This is the behavior of String.replace.\n\t\t\tregexp.lastIndex++\n\t\t}\n\n\t\tif (index !== lastIndex) {\n\t\t\toutput.push(string.substring(lastIndex, index))\n\t\t}\n\n\t\tvar match = result[0]\n\t\tlastIndex = index + match.length\n\t\t\n\t\tvar out = replacerIsFn ?\n\t\t\tnewValueOrFn.apply(this, result.concat(index + globalOffset, result.input)) :\n\t\t\tnewValueOrFn\n\t\toutput.push(out)\n\n\t\tif (!regexp.global) {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif (lastIndex < string.length) {\n\t\toutput.push(string.substring(lastIndex))\n\t}\n\n\tregexp.lastIndex = storedLastIndex\n\treturn output\n}\n\nmodule.exports = function stringReplaceToArray (stringOrArray, regexpOrSubstr, newSubStrOrFn) {\n\tif (typeof stringOrArray === 'string') {\n\t\treturn replace(stringOrArray, regexpOrSubstr, newSubStrOrFn, 0)\n\t} else if (!Array.isArray(stringOrArray) || !stringOrArray[0]) {\n\t\tthrow new TypeError('First argument must be an array or non-empty string')\n\t} else {\n\t\tvar len = stringOrArray.length\n\t\tvar output = []\n\t\tvar globalOffset = 0\n\t\tfor (var i = 0; i < len; ++i) {\n\t\t\tvar arrayItem = stringOrArray[i]\n\t\t\tif (typeof arrayItem === 'string') {\n\t\t\t\toutput.push.apply(output, replace(arrayItem, regexpOrSubstr, newSubStrOrFn, globalOffset))\n\t\t\t\tglobalOffset += arrayItem.length\n\t\t\t} else {\n\t\t\t\toutput.push(arrayItem)\n\t\t\t}\n\t\t}\n\t\treturn output\n\t}\n}"],"mappings":"AAAA;AAEA,SAASA,OAAT,CAAkBC,MAAlB,EAA0BC,cAA1B,EAA0CC,YAA1C,EAAwDC,YAAxD,EAAsE;EACrE,IAAI,OAAOH,MAAP,KAAkB,QAAtB,EAAgC,MAAM,IAAII,KAAJ,CAAU,8BAAV,CAAN;EAChC,IAAI,OAAOH,cAAP,KAA0B,QAA1B,IAAsC,EAAEA,cAAc,YAAYI,MAA5B,CAA1C,EAA+E,MAAM,IAAID,KAAJ,CAAU,+DAAV,CAAN;EAE/E,IAAIE,EAAE,GAAI,OAAOL,cAAP,KAA0B,QAA3B,GAAuCM,kBAAvC,GAA4DC,kBAArE;EAEA,OAAOF,EAAE,CAACN,MAAD,EAASC,cAAT,EAAyBC,YAAzB,EAAuCC,YAAvC,CAAT;AACA;;AAED,SAASI,kBAAT,CAA6BP,MAA7B,EAAqCS,aAArC,EAAoDP,YAApD,EAAkEC,YAAlE,EAAgF;EAC/E,IAAIO,KAAK,GAAGV,MAAM,CAACW,OAAP,CAAeF,aAAf,CAAZ;;EAEA,IAAIC,KAAK,IAAI,CAAb,EAAgB;IACf,IAAIE,GAAG,GAAG,EAAV;IACA,IAAIC,QAAQ,GAAGH,KAAK,GAAGD,aAAa,CAACK,MAArC;;IAEA,IAAIJ,KAAK,GAAG,CAAZ,EAAe;MACdE,GAAG,CAACG,IAAJ,CAASf,MAAM,CAACgB,SAAP,CAAiB,CAAjB,EAAoBN,KAApB,CAAT;IACA;;IAEDE,GAAG,CAACG,IAAJ,CACE,OAAOb,YAAP,KAAwB,UAAzB,GACCA,YAAY,CACXF,MAAM,CAACgB,SAAP,CAAiBN,KAAjB,EAAwBG,QAAxB,CADW,EAEXH,KAAK,GAAGP,YAFG,EAGXH,MAHW,CADb,GAMCE,YAPF;;IAUA,IAAIW,QAAQ,GAAGb,MAAM,CAACc,MAAtB,EAA8B;MAC7BF,GAAG,CAACG,IAAJ,CAASf,MAAM,CAACgB,SAAP,CAAiBH,QAAjB,CAAT;IACA;;IAED,OAAOD,GAAP;EACA,CAvBD,MAuBO;IACN,OAAO,CAACZ,MAAD,CAAP;EACA;AACD;;AAED,SAASQ,kBAAT,CAA6BR,MAA7B,EAAqCiB,MAArC,EAA6Cf,YAA7C,EAA2DC,YAA3D,EAAyE;EACxE,IAAIe,MAAM,GAAG,EAAb;EAEA,IAAIC,YAAY,GAAI,OAAOjB,YAAP,KAAwB,UAA5C;EAEA,IAAIkB,eAAe,GAAGH,MAAM,CAACI,SAA7B;EACAJ,MAAM,CAACI,SAAP,GAAmB,CAAnB;EAEA,IAAIC,MAAJ;EACA,IAAID,SAAS,GAAG,CAAhB;;EACA,OAAOC,MAAM,GAAGL,MAAM,CAACM,IAAP,CAAYvB,MAAZ,CAAhB,EAAqC;IACpC,IAAIU,KAAK,GAAGY,MAAM,CAACZ,KAAnB;;IAEA,IAAIY,MAAM,CAAC,CAAD,CAAN,KAAc,EAAlB,EAAsB;MACrB;MACA;MACA;MACAL,MAAM,CAACI,SAAP;IACA;;IAED,IAAIX,KAAK,KAAKW,SAAd,EAAyB;MACxBH,MAAM,CAACH,IAAP,CAAYf,MAAM,CAACgB,SAAP,CAAiBK,SAAjB,EAA4BX,KAA5B,CAAZ;IACA;;IAED,IAAIc,KAAK,GAAGF,MAAM,CAAC,CAAD,CAAlB;IACAD,SAAS,GAAGX,KAAK,GAAGc,KAAK,CAACV,MAA1B;IAEA,IAAIW,GAAG,GAAGN,YAAY,GACrBjB,YAAY,CAACwB,KAAb,CAAmB,IAAnB,EAAyBJ,MAAM,CAACK,MAAP,CAAcjB,KAAK,GAAGP,YAAtB,EAAoCmB,MAAM,CAACM,KAA3C,CAAzB,CADqB,GAErB1B,YAFD;IAGAgB,MAAM,CAACH,IAAP,CAAYU,GAAZ;;IAEA,IAAI,CAACR,MAAM,CAACY,MAAZ,EAAoB;MACnB;IACA;EACD;;EAED,IAAIR,SAAS,GAAGrB,MAAM,CAACc,MAAvB,EAA+B;IAC9BI,MAAM,CAACH,IAAP,CAAYf,MAAM,CAACgB,SAAP,CAAiBK,SAAjB,CAAZ;EACA;;EAEDJ,MAAM,CAACI,SAAP,GAAmBD,eAAnB;EACA,OAAOF,MAAP;AACA;;AAEDY,MAAM,CAACC,OAAP,GAAiB,SAASC,oBAAT,CAA+BC,aAA/B,EAA8ChC,cAA9C,EAA8DiC,aAA9D,EAA6E;EAC7F,IAAI,OAAOD,aAAP,KAAyB,QAA7B,EAAuC;IACtC,OAAOlC,OAAO,CAACkC,aAAD,EAAgBhC,cAAhB,EAAgCiC,aAAhC,EAA+C,CAA/C,CAAd;EACA,CAFD,MAEO,IAAI,CAACC,KAAK,CAACC,OAAN,CAAcH,aAAd,CAAD,IAAiC,CAACA,aAAa,CAAC,CAAD,CAAnD,EAAwD;IAC9D,MAAM,IAAII,SAAJ,CAAc,qDAAd,CAAN;EACA,CAFM,MAEA;IACN,IAAIC,GAAG,GAAGL,aAAa,CAACnB,MAAxB;IACA,IAAII,MAAM,GAAG,EAAb;IACA,IAAIf,YAAY,GAAG,CAAnB;;IACA,KAAK,IAAIoC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,GAApB,EAAyB,EAAEC,CAA3B,EAA8B;MAC7B,IAAIC,SAAS,GAAGP,aAAa,CAACM,CAAD,CAA7B;;MACA,IAAI,OAAOC,SAAP,KAAqB,QAAzB,EAAmC;QAClCtB,MAAM,CAACH,IAAP,CAAYW,KAAZ,CAAkBR,MAAlB,EAA0BnB,OAAO,CAACyC,SAAD,EAAYvC,cAAZ,EAA4BiC,aAA5B,EAA2C/B,YAA3C,CAAjC;QACAA,YAAY,IAAIqC,SAAS,CAAC1B,MAA1B;MACA,CAHD,MAGO;QACNI,MAAM,CAACH,IAAP,CAAYyB,SAAZ;MACA;IACD;;IACD,OAAOtB,MAAP;EACA;AACD,CApBD"},"metadata":{},"sourceType":"script"}